<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>BITC Bitcoin Pressure Dashboard</title>
    <style>
      :root {
        --bg: #050711;
        --bg-card: #101321;
        --bg-card-soft: #151827;
        --accent: #f7931a;
        --accent-soft: rgba(247, 147, 26, 0.18);
        --up: #16c784;
        --down: #ea3943;
        --text-main: #f9fafb;
        --text-muted: #9ca3af;
        --border-subtle: #1f2933;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        min-height: 100vh;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: radial-gradient(circle at top left, #1b2236 0, #050711 55%, #000 100%);
        color: var(--text-main);
      }
      .shell {
        max-width: 1120px;
        margin: 0 auto;
        padding: 24px 16px 40px;
      }
      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 24px;
      }
      .brand {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .brand-logo {
        width: 32px;
        height: 32px;
        border-radius: 999px;
        background: radial-gradient(circle at 30% 30%, #fff 0, #f7931a 25%, #ef6c00 60%, #8e3e00 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        color: #111827;
        font-weight: 800;
        font-size: 18px;
      }
      .brand-text-main {
        font-weight: 600;
        letter-spacing: 0.04em;
      }
      .brand-text-sub {
        font-size: 12px;
        color: var(--text-muted);
      }
      .tag {
        border-radius: 999px;
        padding: 4px 10px;
        background: rgba(31, 41, 55, 0.7);
        border: 1px solid rgba(75, 85, 99, 0.7);
        font-size: 11px;
        color: var(--text-muted);
      }
      main {
        display: flex;
        flex-direction: column;
        gap: 18px;
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 14px;
      }
      @media (max-width: 900px) {
        .grid {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
      }
      @media (max-width: 640px) {
        .grid {
          grid-template-columns: minmax(0, 1fr);
        }
        header {
          flex-direction: column;
          align-items: flex-start;
          gap: 10px;
        }
      }
      .card {
        background: linear-gradient(145deg, var(--bg-card) 0, #060814 100%);
        border-radius: 16px;
        padding: 14px 16px;
        border: 1px solid rgba(31, 41, 55, 0.85);
        box-shadow: 0 18px 50px rgba(0, 0, 0, 0.7);
      }
      .card-soft {
        background: radial-gradient(circle at top left, #1b2236 0, var(--bg-card-soft) 55%, #050814 100%);
      }
      .card-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 8px;
      }
      .label {
        font-size: 12px;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.12em;
      }
      .metric-main {
        font-size: 26px;
        font-weight: 700;
      }
      .metric-sub {
        font-size: 13px;
        color: var(--text-muted);
      }
      .chip {
        border-radius: 999px;
        padding: 3px 10px;
        font-size: 11px;
        border: 1px solid rgba(55, 65, 81, 0.9);
        background: rgba(15, 23, 42, 0.85);
        color: var(--text-muted);
      }
      .chip-up {
        color: var(--up);
        border-color: rgba(22, 199, 132, 0.35);
        background: rgba(22, 199, 132, 0.1);
      }
      .chip-down {
        color: var(--down);
        border-color: rgba(234, 57, 67, 0.35);
        background: rgba(234, 57, 67, 0.08);
      }
      .chip-neutral {
        color: var(--accent);
        border-color: rgba(247, 147, 26, 0.45);
        background: var(--accent-soft);
      }
      .error {
        margin-bottom: 16px;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid rgba(239, 68, 68, 0.7);
        background: rgba(127, 29, 29, 0.4);
        color: #fecaca;
        font-size: 13px;
      }
      .section-title {
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        color: var(--text-muted);
        margin-bottom: 6px;
      }
      .section-row {
        display: grid;
        grid-template-columns: 2fr 3fr;
        gap: 14px;
      }
      @media (max-width: 900px) {
        .section-row {
          grid-template-columns: minmax(0, 1fr);
        }
      }
      .table {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
      }
      .table th,
      .table td {
        padding: 6px 8px;
        border-bottom: 1px solid var(--border-subtle);
      }
      .table th {
        text-align: left;
        color: var(--text-muted);
        font-weight: 500;
        font-size: 11px;
      }
      .table tbody tr:nth-child(even) {
        background: rgba(15, 23, 42, 0.4);
      }
      .value-up {
        color: var(--up);
      }
      .value-down {
        color: var(--down);
      }
      .value-muted {
        color: var(--text-muted);
      }
      .meta {
        display: flex;
        flex-wrap: wrap;
        gap: 6px 10px;
        margin-top: 6px;
        font-size: 11px;
        color: var(--text-muted);
      }
      .meta span {
        opacity: 0.9;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 3px 9px;
        border-radius: 999px;
        background: rgba(17, 24, 39, 0.85);
        border: 1px solid rgba(55, 65, 81, 0.9);
        font-size: 11px;
        color: var(--text-muted);
      }
      .pill-dot {
        width: 7px;
        height: 7px;
        border-radius: 999px;
      }
      .pill-dot-up {
        background: var(--up);
      }
      .pill-dot-down {
        background: var(--down);
      }
      .pill-dot-neutral {
        background: var(--accent);
      }
      .form-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 6px;
      }
      .field {
        display: flex;
        flex-direction: column;
        gap: 3px;
        min-width: 110px;
        max-width: 140px;
      }
      .field label {
        font-size: 11px;
        color: var(--text-muted);
      }
      .field input {
        background: rgba(15, 23, 42, 0.9);
        border-radius: 8px;
        border: 1px solid rgba(55, 65, 81, 0.9);
        padding: 5px 8px;
        font-size: 12px;
        color: var(--text-main);
      }
      .field input:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 1px rgba(247, 147, 26, 0.5);
      }
      .btn {
        margin-top: 17px;
        padding: 7px 14px;
        border-radius: 999px;
        border: none;
        background: linear-gradient(135deg, #f7931a 0, #fcb045 35%, #ff8a00 100%);
        color: #111827;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.7);
      }
      .btn:hover {
        filter: brightness(1.05);
      }
      .hint {
        margin-top: 6px;
        font-size: 11px;
        color: var(--text-muted);
      }
      .chart-container {
        width: 100%;
        height: 360px;
      }
      .chart-note {
        margin-top: 6px;
        font-size: 11px;
        color: var(--text-muted);
      }
      .tf-toggle {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        font-size: 12px;
        color: var(--text-muted);
      }
      .tf-label {
        opacity: 0.9;
      }
      .tf-btn {
        border-radius: 999px;
        border: 1px solid rgba(55, 65, 81, 0.9);
        background: rgba(15, 23, 42, 0.9);
        color: var(--text-muted);
        font-size: 11px;
        padding: 3px 8px;
        cursor: pointer;
      }
      .tf-btn.active {
        background: var(--accent-soft);
        color: var(--accent);
        border-color: rgba(247, 147, 26, 0.7);
      }
      .market-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
        margin-top: 8px;
      }
      .market-table th,
      .market-table td {
        padding: 6px 8px;
        border-bottom: 1px solid var(--border-subtle);
      }
      .market-table th {
        text-align: left;
        color: var(--text-muted);
        font-weight: 500;
        font-size: 11px;
      }
      .tabs {
        display: flex;
        gap: 8px;
        margin: 12px 0 10px;
      }
      .tab-btn {
        border-radius: 999px;
        border: 1px solid rgba(55, 65, 81, 0.9);
        background: rgba(15, 23, 42, 0.9);
        color: var(--text-muted);
        font-size: 11px;
        padding: 4px 12px;
        cursor: pointer;
      }
      .tab-btn.active {
        background: var(--accent-soft);
        color: var(--accent);
        border-color: rgba(247, 147, 26, 0.7);
      }
      .tab-content {
        display: none;
      }
      .tab-content.active {
        display: block;
      }
      .eval-bars {
        display: flex;
        gap: 1px;
        height: 60px;
        margin-top: 8px;
      }
      .eval-bar {
        flex: 1;
        background: var(--border-subtle);
      }
      .eval-bar.up {
        background: rgba(22, 199, 132, 0.9);
      }
      .eval-bar.down {
        background: rgba(59, 130, 246, 0.9);
      }
      .eval-bar.wrong {
        background: rgba(234, 57, 67, 0.9);
      }
      .live-dot {
        width: 10px;
        height: 10px;
        border-radius: 999px;
        background: #16c784;
        display: inline-block;
        box-shadow: 0 0 0 6px rgba(22, 199, 132, 0.18);
      }
      .live-dot.off {
        background: #9ca3af;
        box-shadow: 0 0 0 4px rgba(156, 163, 175, 0.2);
      }
    </style>
  </head>
  <body>
    <div class="shell">
      <header>
        <div class="brand">
          <div class="brand-logo">₿</div>
          <div>
            <div class="brand-text-main">BITC / BTCUSDT</div>
            <div class="brand-text-sub">1초 캔들 기반 매수·매도 압력 LSTM 시그널</div>
          </div>
        </div>
        <div class="tag">Experimental Quant Dashboard · dev only</div>
      </header>

      {% if error_message %}
        <div class="error">
          대시보드를 로딩하는 중 에러가 발생했습니다:<br />
          {{ error_message }}
        </div>
      {% endif %}

      <div class="tabs" data-active-tab="{{ active_tab }}">
        <button type="button" class="tab-btn active" data-tab="binance">Binance 실시간</button>
        <button type="button" class="tab-btn" data-tab="hybrid">하이브리드 1m 예측</button>
        <button type="button" class="tab-btn" data-tab="paper">하이브리드 모의투자</button>
        <button type="button" class="tab-btn" data-tab="model">전략 / 모델 대시보드</button>
      </div>

      <div id="tab-binance" class="tab-content active">
        <section>
          <div class="section-title">Market View · Binance BTCUSDT 실시간</div>
          <div class="card">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px">
              <div class="tf-toggle">
                <span class="tf-label">타임프레임:</span>
                <button type="button" class="tf-btn active" data-tf="1s">1초</button>
                <button type="button" class="tf-btn" data-tf="1m">1분</button>
                <button type="button" class="tf-btn" data-tf="1h">1시간</button>
              </div>
              <div id="chart-status" style="font-size: 11px; color: var(--text-muted)"></div>
            </div>
            <div id="candles-chart" class="chart-container"></div>
            <div class="chart-note">
              <span>Binance 현물 시세 WebSocket 스트림을 통해 선택한 타임프레임(1초, 1분, 1시간)의 캔들과 거래량을 실시간으로 표시합니다.</span>
            </div>
            <div style="margin-top: 10px">
              <table class="market-table">
                <thead>
                  <tr>
                    <th>시간</th>
                    <th>시가</th>
                    <th>고가</th>
                    <th>저가</th>
                    <th>종가</th>
                    <th>거래량</th>
                  </tr>
                </thead>
                <tbody id="market-table-body">
                  <tr>
                    <td colspan="6" class="value-muted">
                      실시간 캔들이 들어오면 최근 캔들이 여기 표로 정리되어 표시됩니다.
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </section>
      </div>

      <div id="tab-hybrid" class="tab-content">
        <section>
          <div class="section-title">Hybrid Ensemble 1m · 다음 분봉 확률</div>
          <div class="card">
            <div class="card-header">
              <span class="label">models/hybrid_ensemble_1m</span>
              <span class="chip" id="hybrid-status"><span class="live-dot off" id="hybrid-live-dot"></span>&nbsp;대기 중</span>
            </div>
            <div class="grid">
              <div class="card card-soft">
                <div class="card-header">
                  <span class="label">Ensemble prob_up</span>
                  <span class="chip chip-neutral" id="hybrid-direction">예측 대기</span>
                </div>
                <div class="metric-main">
                  <span id="hybrid-prob-ensemble">-</span>
                  <span class="metric-sub">ensemble</span>
                </div>
                <div class="meta">
                  <span>lookback: <span id="hybrid-lookback">-</span></span>
                  <span>horizon(분): <span id="hybrid-horizon">-</span></span>
                  <span>업데이트: <span id="hybrid-updated">-</span></span>
                </div>
              </div>

              <div class="card">
                <div class="card-header">
                  <span class="label">LSTM / XGBoost</span>
                  <span class="chip">가중치</span>
                </div>
                <div class="metric-main">
                  <span id="hybrid-prob-lstm">-</span>
                  <span class="metric-sub">lstm</span>
                </div>
                <div class="meta">
                  <span>xgb <span id="hybrid-prob-xgb">-</span></span>
                  <span>wLSTM: <span id="hybrid-weight-lstm">-</span></span>
                  <span>wXGB: <span id="hybrid-weight-xgb">-</span></span>
                </div>
              </div>

              <div class="card">
                <div class="card-header">
                  <span class="label">현재 캔들</span>
                  <span class="chip chip-neutral" id="hybrid-next-time">-</span>
                </div>
                <div class="metric-main">
                  <span id="hybrid-last-close">-</span>
                  <span class="metric-sub">close</span>
                </div>
                <div class="meta">
                  <span>O <span id="hybrid-last-open">-</span></span>
                  <span>H <span id="hybrid-last-high">-</span></span>
                  <span>L <span id="hybrid-last-low">-</span></span>
                  <span>V <span id="hybrid-last-volume">-</span></span>
                </div>
              </div>
            </div>

            <div style="margin-top: 12px">
              <div id="hybrid-chart" class="chart-container"></div>
              <div class="chart-note">
                LSTM + XGBoost 앙상블이 실시간 Binance 1분 봉에 대해 다음 분(close 기준) 상승 확률을 계산합니다.
                (라벨 horizon: <span id="hybrid-horizon-note">-</span>분)
              </div>
            </div>

            <div style="margin-top: 12px">
              <div class="card">
                <div class="card-header">
                  <span class="label">prob_ensemble 추이 (최근)</span>
                  <span class="chip">0.0 ~ 1.0</span>
                </div>
                <div id="hybrid-prob-chart" style="height: 180px"></div>
              </div>
            </div>
          </div>

          <div class="card" style="margin-top: 12px">
            <div class="card-header">
              <span class="label">최근 예측 스트림</span>
              <span class="chip">ensemble / price</span>
            </div>
            <div style="max-height: 260px; overflow: auto">
              <table class="table">
                <thead>
                  <tr>
                    <th>시각</th>
                    <th>prob_ensemble</th>
                    <th>LSTM</th>
                    <th>XGB</th>
                    <th>close</th>
                  </tr>
                </thead>
                <tbody id="hybrid-prob-table">
                  <tr>
                    <td colspan="5" class="value-muted">API 호출 후 실시간 예측이 여기에 채워집니다.</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </section>
      </div>

      <div id="tab-paper" class="tab-content">
        <section>
          <div class="section-title">Hybrid Model · 실시간 모의 투자</div>
          <div class="card">
            <div class="card-header">
              <span class="label">prob_ensemble 기반 paper trading</span>
              <span class="chip" id="paper-status"><span class="live-dot off" id="paper-live-dot"></span>&nbsp;대기 중</span>
            </div>

            <div class="grid">
              <div class="card card-soft">
                <div class="card-header">
                  <span class="label">계좌 요약</span>
                  <span class="chip chip-neutral" id="paper-last-action">대기 중</span>
                </div>
                <div class="metric-main">
                  <span id="paper-equity">-</span>
                  <span class="metric-sub">equity</span>
                </div>
                <div class="meta">
                  <span>현금: <span id="paper-cash">-</span></span>
                  <span>PnL: <span id="paper-pnl">-</span></span>
                  <span>거래 수: <span id="paper-trade-count">0</span></span>
                </div>
              </div>

              <div class="card">
                <div class="card-header">
                  <span class="label">포지션 상태</span>
                  <span class="chip chip-neutral" id="paper-position-state">미보유</span>
                </div>
                <div class="metric-main">
                  <span id="paper-position-size">-</span>
                  <span class="metric-sub">qty @ price</span>
                </div>
                <div class="meta">
                  <span>진입가: <span id="paper-entry-price">-</span></span>
                  <span>현재가: <span id="paper-current-price">-</span></span>
                  <span>미실현: <span id="paper-unrealized">-</span></span>
                </div>
              </div>

              <div class="card">
                <div class="card-header">
                  <span class="label">실시간 시그널</span>
                  <span class="chip" id="paper-prob-chip">prob</span>
                </div>
                <div class="metric-main">
                  <span id="paper-prob">-</span>
                  <span class="metric-sub">prob_ensemble</span>
                </div>
                <div class="meta">
                  <span>horizon: <span id="paper-horizon">-</span>분</span>
                  <span>업데이트: <span id="paper-updated">-</span></span>
                  <span>가격: <span id="paper-price">-</span></span>
                </div>
              </div>
            </div>

            <div class="card" style="margin-top: 12px">
              <div class="card-header">
                <span class="label">전략 설정</span>
                <span class="chip">탭 활성 시에만 동작</span>
              </div>
              <form id="paper-config" class="form-row" onsubmit="return false;">
                <div class="field">
                  <label for="paper-initial-balance">초기 자본 (USDT)</label>
                  <input id="paper-initial-balance" type="number" step="100" min="100" />
                </div>
                <div class="field">
                  <label for="paper-order-pct">주문 비율 (%)</label>
                  <input id="paper-order-pct" type="number" step="1" min="1" max="100" />
                </div>
                <div class="field">
                  <label for="paper-entry-threshold">매수 조건 (prob ≥)</label>
                  <input id="paper-entry-threshold" type="number" step="0.01" min="0" max="1" />
                </div>
                <div class="field">
                  <label for="paper-short-entry">숏 진입 (prob ≤)</label>
                  <input id="paper-short-entry" type="number" step="0.01" min="0" max="1" />
                </div>
                <div class="field">
                  <label for="paper-exit-threshold">청산 조건 (prob ≤)</label>
                  <input id="paper-exit-threshold" type="number" step="0.01" min="0" max="1" />
                </div>
                <div class="field">
                  <label for="paper-short-exit">숏 청산 (prob ≥)</label>
                  <input id="paper-short-exit" type="number" step="0.01" min="0" max="1" />
                </div>
                <div class="field">
                  <label for="paper-tp">익절 한계 (%)</label>
                  <input id="paper-tp" type="number" step="0.1" min="0" />
                </div>
                <div class="field">
                  <label for="paper-sl">손절 한계 (%)</label>
                  <input id="paper-sl" type="number" step="0.1" min="-50" />
                </div>
                <button class="btn" type="button" id="paper-reset-btn">자본/상태 초기화</button>
              </form>
              <div class="hint">
                prob_ensemble·가격이 3초마다 업데이트될 때마다 조건에 맞으면 가상 포지션을 열고 닫습니다.
                탭을 닫으면 시뮬레이션도 자동으로 멈춥니다.
              </div>
            </div>

            <div class="card" style="margin-top: 12px">
              <div class="card-header">
                <span class="label">모의 체결 내역</span>
                <span class="chip">최근 20건</span>
              </div>
              <div style="max-height: 240px; overflow: auto">
                <table class="table">
                  <thead>
                    <tr>
                      <th>포지션</th>
                      <th>진입</th>
                      <th>청산</th>
                      <th>진입가</th>
                      <th>청산가</th>
                      <th>PnL</th>
                      <th>prob</th>
                    </tr>
                  </thead>
                  <tbody id="paper-trades-body">
                    <tr>
                      <td colspan="7" class="value-muted">
                        탭을 열면 실시간 예측으로 체결 시나리오가 표시됩니다.
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </section>
      </div>

      <div id="tab-model" class="tab-content">
      <form method="get" style="margin-bottom: 12px; display: flex; flex-wrap: wrap; gap: 8px; align-items: flex-end">
        <div class="field" style="min-width: 200px">
          <label for="model_path">모델 (models/*.pt)</label>
          <select id="model_path" name="model_path" style="padding: 6px 8px; border-radius: 8px; background: rgba(15,23,42,0.9); color: var(--text-main); border: 1px solid rgba(55,65,81,0.9);">
            <option value="">-- 선택 --</option>
            {% for m in model_files %}
              <option value="{{ m }}" {% if selected_model|slice:"-{{m|length}}" == m %}selected{% endif %}>{{ m }}</option>
            {% endfor %}
          </select>
        </div>
        <div class="field" style="min-width: 240px">
          <label for="validate_file">검증 CSV (dataset/validate)</label>
          <select id="validate_file" name="validate_file" style="padding: 6px 8px; border-radius: 8px; background: rgba(15,23,42,0.9); color: var(--text-main); border: 1px solid rgba(55,65,81,0.9);">
            <option value="">-- 선택 --</option>
            {% for f in validate_files %}
              <option value="{{ f }}" {% if selected_validate|slice:"-{{f|length}}" == f %}selected{% endif %}>{{ f }}</option>
            {% endfor %}
          </select>
        </div>
        <div class="field" style="min-width: 140px">
          <label>&nbsp;</label>
          <input type="hidden" name="tab" value="model" />
          <button class="btn" type="submit">선택한 모델/데이터로 검증</button>
        </div>
      </form>

      {% if snapshot %}
        <main>
          <section>
            <div class="section-title">LSTM 검증 결과 (dataset/validate 최신 파일)</div>
            <div class="card">
              {% if lstm_eval and not lstm_eval.error and lstm_eval.accuracy %}
                <div class="card-header">
                  <span class="label">btc_lstm.pt</span>
                  <span class="chip">validate</span>
                </div>
                <div class="metric-main">
                  {{ lstm_eval.accuracy_pct|floatformat:2 }}%
                  <span class="metric-sub">accuracy</span>
                </div>
                <div class="meta">
                  <span>파일: {{ lstm_eval.file }}</span>
                  <span>시퀀스: {{ lstm_eval.total_sequences }}</span>
                  <span>lookback: {{ lstm_eval.lookback }}</span>
                  <span>checkpoint: {{ lstm_eval.checkpoint }}</span>
                  <span>device: {{ lstm_eval.device }}</span>
                </div>
                {% if lstm_eval.samples %}
                  <div class="eval-bars" title="최근 {{ lstm_eval.samples|length }}개 시퀀스의 예측 일치 여부">
                    {% for s in lstm_eval.samples %}
                      <div
                        class="eval-bar {% if s.correct %}{% if s.pred_up %}up{% else %}down{% endif %}{% else %}wrong{% endif %}"
                        title="{{ s.timestamp }} · 실제 {{ s.actual_up }} / 예측 {{ s.pred_up }} · close {{ s.close|floatformat:2 }}"
                      ></div>
                    {% endfor %}
                  </div>
                  <div class="meta" style="margin-top: 6px">
                    <span>초록=상승 맞음 · 파랑=하락 맞음 · 빨강=틀림</span>
                  </div>
                {% endif %}
              {% else %}
                <div class="hint">
                  {% if lstm_eval and lstm_eval.error %}
                    LSTM 검증을 수행하지 못했습니다: {{ lstm_eval.error }}
                  {% else %}
                    LSTM 검증 결과를 불러올 수 없습니다. 체크포인트와 검증 CSV를 확인해 주세요.
                  {% endif %}
                </div>
              {% endif %}
            </div>
          </section>

          <section>
            <div class="section-title">Last Candle · 마지막 캔들 스냅샷</div>
            <div class="grid">
              <div class="card card-soft">
                <div class="card-header">
                  <span class="label">모델 시그널</span>
                  {% if trade and trade.current %}
                    {% if trade.current.expected_profit_pct > 0 %}
                      <span class="chip chip-up">양(+) 기대 수익 구간</span>
                    {% elif trade.current.expected_profit_pct < 0 %}
                      <span class="chip chip-down">음(-) 기대 수익 구간</span>
                    {% else %}
                      <span class="chip chip-neutral">중립 구간</span>
                    {% endif %}
                  {% else %}
                    <span class="chip chip-neutral">모델 결과</span>
                  {% endif %}
                </div>
                <div class="metric-main">
                  {{ snapshot.prob_up|floatformat:3 }}
                  <span class="metric-sub">prob_up</span>
                </div>
                <div class="meta">
                  <span>캔들: {{ snapshot.timestamp }}</span>
                  <span>디바이스: {{ snapshot.device }}</span>
                  <span>Lookback: {{ snapshot.lookback }}초 · Tail: {{ snapshot.tail_rows }}행</span>
                </div>
              </div>

              <div class="card">
                <div class="card-header">
                  <span class="label">가격 / 변동</span>
                  {% if snapshot.price_close and snapshot.price_open %}
                    {% with diff=snapshot.price_close|floatformat:2|add:"-0" %}
                    {% endwith %}
                  {% endif %}
                </div>
                <div class="metric-main">
                  {{ snapshot.price_close|floatformat:2 }}
                  <span class="metric-sub">USDT</span>
                </div>
                <div class="meta">
                  <span>O {{ snapshot.price_open|floatformat:2 }}</span>
                  <span>H {{ snapshot.price_high|floatformat:2 }}</span>
                  <span>L {{ snapshot.price_low|floatformat:2 }}</span>
                  <span>C {{ snapshot.price_close|floatformat:2 }}</span>
                </div>
              </div>

              <div class="card">
                <div class="card-header">
                  <span class="label">검증 성능</span>
                  <span class="chip">validation</span>
                </div>
                <div class="metric-main">
                  {{ snapshot.val_accuracy|floatformat:3 }}
                  <span class="metric-sub">val acc</span>
                </div>
                <div class="meta">
                  <span>loss {{ snapshot.val_loss|floatformat:4 }}</span>
                </div>
              </div>
            </div>
          </section>

          <section>
            <div class="section-row">
              <div>
                <div class="section-title">Trade Simulation · 손익 시나리오</div>
                <div class="card">
                  <form method="get">
                    <div class="form-row">
                      <div class="field">
                        <label for="prob_threshold">prob_up ≥</label>
                        <input
                          id="prob_threshold"
                          name="prob_threshold"
                          type="number"
                          step="0.01"
                          min="0"
                          max="1"
                          value="{{ config.prob_threshold }}"
                        />
                      </div>
                      <div class="field">
                        <label for="horizon">보유 시간 (초)</label>
                        <input
                          id="horizon"
                          name="horizon"
                          type="number"
                          min="1"
                          value="{{ config.horizon }}"
                        />
                      </div>
                      <div class="field">
                        <label for="risk_reward">손익비 (목표:손절)</label>
                        <input
                          id="risk_reward"
                          name="risk_reward"
                          type="number"
                          step="0.1"
                          min="0.1"
                          value="{{ config.risk_reward }}"
                        />
                      </div>
                      <div class="field">
                        <label for="min_expected_pct">최소 기대 수익률 (%)</label>
                        <input
                          id="min_expected_pct"
                          name="min_expected_pct"
                          type="number"
                          step="0.1"
                          value="{{ config.min_expected_pct }}"
                        />
                      </div>
                      <div class="field">
                        <label for="fee_rate">수수료 비율</label>
                        <input
                          id="fee_rate"
                          name="fee_rate"
                          type="number"
                          step="0.0001"
                          value="{{ config.fee_rate }}"
                        />
                      </div>
                      <div class="field">
                        <label for="slippage_rate">슬리피지 비율</label>
                        <input
                          id="slippage_rate"
                          name="slippage_rate"
                          type="number"
                          step="0.0001"
                          value="{{ config.slippage_rate }}"
                        />
                      </div>
                      <button class="btn" type="submit">시뮬레이션 업데이트</button>
                    </div>
                    <div class="hint">
                      위 파라미터는 모델이 계산한 과거·현재 구간의 단순 손익 시나리오를 바꾸는 값입니다.
                      실제 매매 판단에는 리스크 관리와 슬리피지, 체결 상황 등을 추가로 고려해야 합니다.
                    </div>
                  </form>
                </div>

                {% if trade and trade.current %}
                  <div style="height: 8px"></div>
                  <div class="card">
                    <div class="card-header">
                      <span class="label">현재 캔들 기준 기대 수익</span>
                      {% if trade.current.expected_profit_pct > 0 %}
                        <div class="pill">
                          <span class="pill-dot pill-dot-up"></span>
                          <span>양(+) 기대값 구간</span>
                        </div>
                      {% elif trade.current.expected_profit_pct < 0 %}
                        <div class="pill">
                          <span class="pill-dot pill-dot-down"></span>
                          <span>음(-) 기대값 구간</span>
                        </div>
                      {% else %}
                        <div class="pill">
                          <span class="pill-dot pill-dot-neutral"></span>
                          <span>중립</span>
                        </div>
                      {% endif %}
                    </div>
                    <div class="metric-main">
                      {{ trade.current.expected_profit_pct|floatformat:3 }}%
                      <span class="metric-sub">expected PnL</span>
                    </div>
                    <div class="meta">
                      <span>가정 매수가: {{ trade.current.entry_price|floatformat:2 }} USDT</span>
                      <span>목표가: {{ trade.current.target_price|floatformat:2 }}</span>
                      <span>손절가: {{ trade.current.stop_price|floatformat:2 }}</span>
                      <span>수수료+슬리피지: {{ trade.current.total_cost_rate|floatformat:4 }}</span>
                    </div>
                  </div>
                {% endif %}
              </div>

              <div>
                <div class="section-title">Historical Opportunity · 과거 데이터 기준 최적 구간</div>
                <div class="card">
                  {% if trade and trade.best_trade %}
                    <table class="table">
                      <thead>
                        <tr>
                          <th>구분</th>
                          <th>값</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <td>진입 시점</td>
                          <td class="value-muted">{{ trade.best_trade.entry_time }}</td>
                        </tr>
                        <tr>
                          <td>진입 가격</td>
                          <td>{{ trade.best_trade.entry_price|floatformat:2 }} USDT</td>
                        </tr>
                        <tr>
                          <td>청산 시점</td>
                          <td class="value-muted">{{ trade.best_trade.exit_time }}</td>
                        </tr>
                        <tr>
                          <td>청산 가격</td>
                          <td>{{ trade.best_trade.exit_price|floatformat:2 }} USDT</td>
                        </tr>
                        <tr>
                          <td>순익 (수수료/슬리피지 반영)</td>
                          <td>
                            {% if trade.best_trade.profit_pct >= 0 %}
                              <span class="value-up">
                                {{ trade.best_trade.profit|floatformat:4 }} ({{ trade.best_trade.profit_pct|floatformat:3 }}%)
                              </span>
                            {% else %}
                              <span class="value-down">
                                {{ trade.best_trade.profit|floatformat:4 }} ({{ trade.best_trade.profit_pct|floatformat:3 }}%)
                              </span>
                            {% endif %}
                          </td>
                        </tr>
                      </tbody>
                    </table>
                  {% else %}
                    <div class="hint">
                      현재 설정(prob_up ≥ {{ config.prob_threshold }}, 보유 {{ config.horizon }}초 등)을 만족하는
                      고확률 구간을 찾지 못했습니다. 파라미터를 조금 완화해서 다시 시도해 볼 수 있습니다.
                    </div>
                  {% endif %}
                </div>
              </div>
            </div>
          </section>

          <section>
            <div class="section-title">Flow · 전체 시그널{% if recent_summary %} ({{ recent_summary.window }}){% endif %}</div>
            <div class="card">
              {% if show_flow and recent_summary and recent_rows %}
                <div class="meta" style="margin-bottom: 8px">
                  <span>평균 prob_up: {{ recent_summary.avg_prob_up|floatformat:3 }}</span>
                  <span>prob_up ≥ 0.55 비중: {{ recent_summary.bullish_ratio|floatformat:1 }}%</span>
                  <span>매수 우위(signal&gt;0) 비중: {{ recent_summary.signal_up_ratio|floatformat:1 }}%</span>
                </div>
                <div style="max-height: 260px; overflow: auto">
                  <table class="table">
                    <thead>
                      <tr>
                        <th>시각</th>
                        <th>종가</th>
                        <th>prob_up</th>
                        <th>signal</th>
                        <th>buy_ratio</th>
                      </tr>
                    </thead>
                    <tbody>
                      {% for row in recent_rows %}
                        <tr>
                          <td class="value-muted">{{ row.timestamp }}</td>
                          <td>{{ row.close|floatformat:2 }}</td>
                          <td>
                            {% if row.prob_up >= 0.55 %}
                              <span class="value-up">{{ row.prob_up|floatformat:3 }}</span>
                            {% elif row.prob_up <= 0.45 %}
                              <span class="value-down">{{ row.prob_up|floatformat:3 }}</span>
                            {% else %}
                              {{ row.prob_up|floatformat:3 }}
                            {% endif %}
                          </td>
                          <td>
                            {% if row.signal > 0 %}
                              <span class="value-up">+1</span>
                            {% elif row.signal < 0 %}
                              <span class="value-down">-1</span>
                            {% else %}
                              0
                            {% endif %}
                          </td>
                          <td>{{ row.buy_ratio|floatformat:3 }}</td>
                        </tr>
                      {% endfor %}
                    </tbody>
                  </table>
                </div>
              {% else %}
                <div class="hint">
                  전체 플로우는 데이터가 많아 로딩에 시간이 걸릴 수 있습니다. 보기 버튼을 눌러 필요한 경우에만 불러오세요.
                </div>
                <form method="get">
                  <input type="hidden" name="model_path" value="{{ selected_model }}" />
                  <input type="hidden" name="validate_file" value="{{ selected_validate }}" />
                  <input type="hidden" name="prob_threshold" value="{{ config.prob_threshold }}" />
                  <input type="hidden" name="horizon" value="{{ config.horizon }}" />
                  <input type="hidden" name="risk_reward" value="{{ config.risk_reward }}" />
                  <input type="hidden" name="min_expected_pct" value="{{ config.min_expected_pct }}" />
                  <input type="hidden" name="fee_rate" value="{{ config.fee_rate }}" />
                  <input type="hidden" name="slippage_rate" value="{{ config.slippage_rate }}" />
                  <input type="hidden" name="tab" value="model" />
                  <input type="hidden" name="show_flow" value="1" />
                  <button class="btn" type="submit">전체 플로우 보기</button>
                </form>
              {% endif %}
            </div>
          </section>
        </main>
      {% else %}
        <div class="error">표시할 스냅샷 데이터가 없습니다. CSV 경로와 데이터셋 준비 상태를 먼저 확인해 주세요.</div>
      {% endif %}
      </div>
    </div>

    <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
    <script>
      (function () {
        if (typeof LightweightCharts === "undefined") {
          return;
        }
        const container = document.getElementById("candles-chart");
        const statusEl = document.getElementById("chart-status");
        if (!container) {
          return;
        }

        const chart = LightweightCharts.createChart(container, {
          layout: {
            background: { color: "#050711" },
            textColor: "#9ca3af",
          },
          grid: {
            vertLines: { color: "rgba(31,41,55,0.4)" },
            horzLines: { color: "rgba(31,41,55,0.4)" },
          },
          timeScale: {
            timeVisible: true,
            secondsVisible: true,
          },
          rightPriceScale: {
            borderColor: "rgba(55,65,81,0.8)",
          },
          crosshair: {
            mode: LightweightCharts.CrosshairMode.Normal,
          },
        });

        const candleSeries = chart.addCandlestickSeries({
          upColor: "#16c784",
          downColor: "#ea3943",
          wickUpColor: "#16c784",
          wickDownColor: "#ea3943",
          borderUpColor: "#16c784",
          borderDownColor: "#ea3943",
        });

        const volumeSeries = chart.addHistogramSeries({
          priceFormat: { type: "volume" },
          priceScaleId: "volume",
          scaleMargins: {
            top: 0.8,
            bottom: 0,
          },
        });

        function setStatus(msg) {
          if (statusEl) {
            statusEl.textContent = msg || "";
          }
        }

        let ws = null;
        const MAX_POINTS = 1000;
        let liveBuffer = [];
        let tickCount = 0;
        let currentTf = "1s";
        let activeTab = null;

        function stopBinanceMode() {
          if (ws) {
            ws.close();
            ws = null;
          }
          setStatus("Binance 탭 비활성 / 연결 안 됨");
        }

        function startPriceStream() {
          if (priceWs) {
            priceWs.close();
            priceWs = null;
          }
          try {
            priceWs = new WebSocket("wss://stream.binance.com:9443/ws/btcusdt@miniTicker");
          } catch (e) {
            priceWs = null;
            return;
          }
          priceWs.onmessage = function (event) {
            try {
              const msg = JSON.parse(event.data);
              const price = parseFloat(msg.c);
              if (!Number.isNaN(price)) {
                lastPrice = price;
                // 최신 prob/메트릭과 조합해 현재가만 새로 고침
                const base = lastHybridPayload ? { ...lastHybridPayload } : {};
                const latest = { ...(base.latest || {}), close: price };
                base.latest = latest;
                handlePaperTick(base);
                if (activeTab === "hybrid" && hybridLiveDot) {
                  hybridLiveDot.classList.remove("off");
                }
              }
            } catch (e) {
              // ignore parse errors
            }
          };
          priceWs.onerror = function () {
            stopPriceStream();
          };
        }

        function stopPriceStream() {
          if (priceWs) {
            try {
              priceWs.close();
            } catch (e) {
              // ignore
            }
            priceWs = null;
          }
        }

        function renderTable(buffer) {
          const body = document.getElementById("market-table-body");
          if (!body) return;
          if (!buffer || buffer.length === 0) {
            body.innerHTML =
              '<tr><td colspan="6" class="value-muted">아직 수신된 캔들이 없습니다.</td></tr>';
            return;
          }

          const rows = [];
          const slice = buffer.slice(-20).reverse();
          slice.forEach(function (c) {
            const d = new Date(c.time * 1000);
            const timeLabel = d.toLocaleTimeString();
            rows.push(
              "<tr>" +
                '<td class="value-muted">' +
                timeLabel +
                "</td>" +
                "<td>" +
                c.open.toFixed(1) +
                "</td>" +
                "<td>" +
                c.high.toFixed(1) +
                "</td>" +
                "<td>" +
                c.low.toFixed(1) +
                "</td>" +
                "<td>" +
                c.close.toFixed(1) +
                "</td>" +
                "<td>" +
                c.volume.toFixed(3) +
                "</td>" +
                "</tr>",
            );
          });
          body.innerHTML = rows.join("");
        }

        function startBinanceMode(tf) {
          if (activeTab !== "binance") {
            stopBinanceMode();
            return;
          }
          stopBinanceMode();
          const tfLabel = tf || currentTf || "1s";
          currentTf = tfLabel;
          setStatus("소스: Binance 실시간 연결 중… (" + tfLabel + ")");
          liveBuffer = [];
          tickCount = 0;

          const intervalMap = {
            "1s": "kline_1s",
            "1m": "kline_1m",
            "1h": "kline_1h",
          };
          const interval = intervalMap[tfLabel] || intervalMap["1s"];

          // 과거 히스토리 로드 (1분/1시간)
          if (tfLabel !== "1s") {
            (async function loadHistory() {
              try {
                const url =
                  "https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=" +
                  tfLabel +
                  "&limit=" +
                  MAX_POINTS;
                const res = await fetch(url);
                if (!res.ok) {
                  return;
                }
                const arr = await res.json();
                if (!Array.isArray(arr)) {
                  return;
                }
                liveBuffer = arr.map(function (k) {
                  const openTime = k[0];
                  const open = parseFloat(k[1]);
                  const high = parseFloat(k[2]);
                  const low = parseFloat(k[3]);
                  const close = parseFloat(k[4]);
                  const volume = parseFloat(k[5]);
                  return {
                    time: Math.floor(openTime / 1000),
                    open,
                    high,
                    low,
                    close,
                    volume,
                  };
                });
                if (liveBuffer.length > MAX_POINTS) {
                  liveBuffer = liveBuffer.slice(liveBuffer.length - MAX_POINTS);
                }
                candleSeries.setData(liveBuffer);
                const vols = liveBuffer.map(function (c) {
                  const isUp = c.close >= c.open;
                  return {
                    time: c.time,
                    value: c.volume,
                    color: isUp ? "#16c784" : "#ea3943",
                  };
                });
                volumeSeries.setData(vols);
                renderTable(liveBuffer);
                chart.timeScale().fitContent();
              } catch (e) {
                if (console && console.error) {
                  console.error("history load failed", e);
                }
              }
            })();
          }

          try {
            ws = new WebSocket(
              "wss://stream.binance.com:9443/ws/btcusdt@" + interval,
            );
          } catch (e) {
            setStatus("Binance WebSocket 생성 실패");
            return;
          }

          ws.onopen = function () {
            setStatus("소스: Binance 실시간 (BTCUSDT " + tfLabel + ") · 연결됨");
          };

          ws.onclose = function () {
            setStatus("Binance 연결 종료됨");
          };

          ws.onerror = function () {
            setStatus("Binance WebSocket 에러");
          };

          ws.onmessage = function (event) {
            try {
              const msg = JSON.parse(event.data);
              const k = msg.k;
              if (!k) {
                return;
              }
              const t = Math.floor(k.t / 1000);
              const open = parseFloat(k.o);
              const high = parseFloat(k.h);
              const low = parseFloat(k.l);
              const close = parseFloat(k.c);
              const volume = parseFloat(k.v);

              tickCount += 1;
              setStatus(
                "Binance 실시간 수신 중 (" +
                  tfLabel +
                  ") · 틱 " +
                  tickCount +
                  "개 · 현재가 " +
                  close.toFixed(1),
              );

              const candle = { time: t, open, high, low, close, volume };

              const last = liveBuffer[liveBuffer.length - 1];
              if (last && last.time === t) {
                liveBuffer[liveBuffer.length - 1] = candle;
              } else {
                liveBuffer.push(candle);
              }
              if (liveBuffer.length > MAX_POINTS) {
                liveBuffer = liveBuffer.slice(liveBuffer.length - MAX_POINTS);
              }

              candleSeries.setData(liveBuffer);

              const vols = liveBuffer.map(function (c) {
                const isUp = c.close >= c.open;
                return {
                  time: c.time,
                  value: c.volume,
                  color: isUp ? "#16c784" : "#ea3943",
                };
              });
              volumeSeries.setData(vols);

              renderTable(liveBuffer);
            } catch (e) {
              if (console && console.error) {
                console.error("Binance message parse error", e);
              }
            }
          };
        }

        // --- Hybrid ensemble (1m) ---
        const hybridStatus = document.getElementById("hybrid-status");
        const hybridLiveDot = document.getElementById("hybrid-live-dot");
        const hybridTableBody = document.getElementById("hybrid-prob-table");
        let hybridChart = null;
        let hybridCandleSeries = null;
        let hybridProbSeries = null;
        let hybridProbOnlyChart = null;
        let hybridProbOnlySeries = null;
        const HYBRID_INTERVAL_MS = 1000;
        const HYBRID_LABEL_HORIZON = 1;
        let lastHybridPayload = null;
        let hybridTimer = null;
        let hybridActive = false;
        let hybridEventSource = null;
        let priceWs = null;
        let lastPrice = null;

        function ensureHybridChart() {
          if (hybridChart) return;
          const hybridContainer = document.getElementById("hybrid-chart");
          if (!hybridContainer) return;
          hybridChart = LightweightCharts.createChart(hybridContainer, {
            layout: { background: { color: "#050711" }, textColor: "#9ca3af" },
            grid: { vertLines: { color: "rgba(31,41,55,0.4)" }, horzLines: { color: "rgba(31,41,55,0.4)" } },
            timeScale: { timeVisible: true, secondsVisible: false },
            rightPriceScale: { borderColor: "rgba(55,65,81,0.8)" },
          });
          hybridCandleSeries = hybridChart.addCandlestickSeries({
            upColor: "#16c784",
            downColor: "#ea3943",
            wickUpColor: "#16c784",
            wickDownColor: "#ea3943",
            borderUpColor: "#16c784",
            borderDownColor: "#ea3943",
          });
          hybridProbSeries = hybridChart.addLineSeries({
            color: "#f59e0b",
            lineWidth: 2,
            priceScaleId: "prob",
          });
          hybridChart.priceScale("prob").applyOptions({
            autoScale: true,
            scaleMargins: { top: 0.05, bottom: 0.65 },
          });

          const probOnlyContainer = document.getElementById("hybrid-prob-chart");
          if (probOnlyContainer) {
            hybridProbOnlyChart = LightweightCharts.createChart(probOnlyContainer, {
              layout: { background: { color: "#050711" }, textColor: "#9ca3af" },
              grid: { vertLines: { color: "rgba(31,41,55,0.25)" }, horzLines: { color: "rgba(31,41,55,0.25)" } },
              timeScale: { timeVisible: true, secondsVisible: false },
              rightPriceScale: { borderColor: "rgba(55,65,81,0.8)" },
            });
            hybridProbOnlySeries = hybridProbOnlyChart.addAreaSeries({
              lineColor: "#f59e0b",
              topColor: "rgba(245,158,11,0.35)",
              bottomColor: "rgba(245,158,11,0.05)",
              lineWidth: 2,
            });
            hybridProbOnlyChart.priceScale("right").applyOptions({
              autoScale: true,
              scaleMargins: { top: 0.05, bottom: 0.05 },
            });
            hybridProbOnlySeries.applyOptions({ priceFormat: { minMove: 0.0001, precision: 4 } });
          }
        }

        function toUnix(ts) {
          if (!ts) return null;
          const d = ts instanceof Date ? ts : new Date(ts);
          return Math.floor(d.getTime() / 1000);
        }

        function renderHybridTable(samples) {
          if (!hybridTableBody) return;
          if (!samples || samples.length === 0) {
            hybridTableBody.innerHTML =
              '<tr><td colspan="5" class="value-muted">예측 샘플을 불러오지 못했습니다.</td></tr>';
            return;
          }
          const rows = [];
          const recent = samples.slice(-30).reverse();
          recent.forEach(function (s) {
            const t = new Date(s.timestamp);
            const timeLabel = t.toLocaleTimeString();
            const ensemble = parseFloat(s.prob_ensemble || 0);
            const lstm = parseFloat(s.prob_lstm || 0);
            const xgb = parseFloat(s.prob_xgb || 0);
            rows.push(
              "<tr>" +
                '<td class="value-muted">' +
                timeLabel +
                "</td>" +
                "<td>" +
                ensemble.toFixed(3) +
                "</td>" +
                "<td>" +
                lstm.toFixed(3) +
                "</td>" +
                "<td>" +
                xgb.toFixed(3) +
                "</td>" +
                "<td>" +
                parseFloat(s.close || 0).toFixed(2) +
                "</td>" +
                "</tr>",
            );
          });
          hybridTableBody.innerHTML = rows.join("");
        }

        function renderHybridChart(payload) {
          ensureHybridChart();
          if (!hybridChart || !hybridCandleSeries || !hybridProbSeries) return;
          const candles = (payload.candles || []).map(function (c) {
            return {
              time: toUnix(c.timestamp),
              open: c.open,
              high: c.high,
              low: c.low,
              close: c.close,
            };
          });
          if (candles.length > 0) {
            hybridCandleSeries.setData(candles);
          }
          const probSamples = (payload.prob_samples || []).map(function (s) {
            return { time: toUnix(s.timestamp), value: s.prob_ensemble };
          });
          if (probSamples.length > 0) {
            hybridProbSeries.setData(probSamples);
            if (hybridProbOnlySeries) {
              hybridProbOnlySeries.setData(probSamples);
              if (hybridProbOnlyChart) {
                hybridProbOnlyChart.timeScale().fitContent();
              }
            }
          }
          if (candles.length > 0) {
            hybridChart.timeScale().fitContent();
          }
        }

        function setHybridMetrics(payload) {
          const dirEl = document.getElementById("hybrid-direction");
          if (dirEl) {
            dirEl.classList.remove("chip-up", "chip-down", "chip-neutral");
            if (payload.pred_direction > 0) {
              dirEl.classList.add("chip-up");
              dirEl.textContent = "상승 기대";
            } else {
              dirEl.classList.add("chip-down");
              dirEl.textContent = "하락 기대";
            }
          }
          const setText = (id, text) => {
            const el = document.getElementById(id);
            if (el) el.textContent = text;
          };
          const livePrice = lastPrice != null ? lastPrice : payload.latest?.close;
          setText("hybrid-prob-ensemble", (payload.prob_ensemble || 0).toFixed(3));
          setText("hybrid-prob-lstm", (payload.prob_lstm || 0).toFixed(3));
          setText("hybrid-prob-xgb", (payload.prob_xgb || 0).toFixed(3));
          setText("hybrid-weight-lstm", (payload.weights?.lstm || 0).toFixed(2));
          setText("hybrid-weight-xgb", (payload.weights?.xgb || 0).toFixed(2));
          setText("hybrid-lookback", payload.lookback);
          setText("hybrid-horizon", payload.label_horizon);
          setText("hybrid-horizon-note", payload.label_horizon);
          setText("hybrid-updated", payload.timestamp ? new Date(payload.timestamp).toLocaleTimeString() : "-");
          setText("hybrid-next-time", payload.next_target_time ? "목표: " + new Date(payload.next_target_time).toLocaleTimeString() : "-");
          if (payload.latest) {
            setText("hybrid-last-close", livePrice != null ? parseFloat(livePrice || 0).toFixed(2) : "-");
            setText("hybrid-last-open", parseFloat(payload.latest.open || 0).toFixed(2));
            setText("hybrid-last-high", parseFloat(payload.latest.high || 0).toFixed(2));
            setText("hybrid-last-low", parseFloat(payload.latest.low || 0).toFixed(2));
            setText("hybrid-last-volume", parseFloat(payload.latest.volume || 0).toFixed(3));
          }
          if (hybridStatus) {
            const latency = payload.latency_ms != null ? ` · latency ${payload.latency_ms}ms` : "";
            const server = payload.server_time ? ` · 서버 ${new Date(payload.server_time).toLocaleTimeString()}` : "";
            hybridStatus.textContent =
              "실시간 " + payload.symbol + " · 최신 " + (payload.candles?.length || 0) + "분" + latency + server;
          }
        }

        async function fetchHybridData() {
          const res = await fetch("/api/hybrid-live/?label_horizon=" + HYBRID_LABEL_HORIZON);
          const data = await res.json();
          if (!res.ok || data.error) {
            throw new Error(data.error || "hybrid API error");
          }
          return data;
        }

        function applyHybridPayload(data, sourceLabel) {
          if (lastPrice != null) {
            data.latest = { ...(data.latest || {}), close: lastPrice };
          }
          lastHybridPayload = data;
          if (activeTab === "hybrid") {
            setHybridMetrics(data);
            renderHybridChart(data);
            renderHybridTable(data.prob_samples || []);
            if (hybridLiveDot) {
              hybridLiveDot.classList.remove("off");
            }
            if (hybridStatus) {
              const label = sourceLabel ? sourceLabel + " · " : "";
              hybridStatus.textContent = label + "갱신 " + new Date().toLocaleTimeString();
            }
          }
          if (paperActive && activeTab === "paper") {
            handlePaperTick(data);
          }
        }

        async function fetchHybridPrediction(label) {
          if (!hybridActive && activeTab !== "paper") return;
          if (hybridStatus && activeTab === "hybrid") {
            hybridStatus.textContent = "실시간 예측 요청 중…";
          }
          if (hybridLiveDot && activeTab === "hybrid") {
            hybridLiveDot.classList.add("off");
          }
          try {
            const data = await fetchHybridData();
            applyHybridPayload(data, label || "폴링");
          } catch (err) {
            if (hybridStatus && activeTab === "hybrid") {
              hybridStatus.textContent = "에러: " + err.message;
            }
            startHybridPolling(); // fallback if SSE failed
          }
        }

        function startHybridPolling() {
          if (activeTab !== "hybrid" && activeTab !== "paper") return;
          hybridActive = true;
          fetchHybridPrediction("폴링");
          if (hybridTimer) {
            clearInterval(hybridTimer);
          }
          hybridTimer = setInterval(function () {
            fetchHybridPrediction("폴링");
          }, HYBRID_INTERVAL_MS);
        }

        function stopHybridPolling() {
          hybridActive = false;
          if (hybridTimer) {
            clearInterval(hybridTimer);
            hybridTimer = null;
          }
        }

        function startHybridStream() {
          if (activeTab !== "hybrid" && activeTab !== "paper") return;
          stopHybridStream();
          hybridActive = true;
          if (!window.EventSource) {
            startHybridPolling();
            return;
          }
          if (hybridStatus && activeTab === "hybrid") {
            hybridStatus.textContent = "SSE 연결 중…";
          }
          hybridEventSource = new EventSource(
            "/api/hybrid-live-stream?interval_ms=" + HYBRID_INTERVAL_MS + "&label_horizon=" + HYBRID_LABEL_HORIZON,
          );
          hybridEventSource.onmessage = function (event) {
            try {
              const data = JSON.parse(event.data);
              applyHybridPayload(data, "스트림");
            } catch (e) {
              if (hybridEventSource) {
                hybridEventSource.close();
                hybridEventSource = null;
              }
              startHybridPolling();
            }
          };
          hybridEventSource.onerror = function () {
            if (hybridEventSource) {
              hybridEventSource.close();
              hybridEventSource = null;
            }
            startHybridPolling();
          };
          // 즉시 한 번 당겨서 초기화
          fetchHybridPrediction("초기화");
        }

        function stopHybridStream() {
          hybridActive = false;
          if (hybridEventSource) {
            hybridEventSource.close();
            hybridEventSource = null;
          }
          stopHybridPolling();
          if (hybridStatus && activeTab === "hybrid") {
            hybridStatus.textContent = "탭 비활성 · 중지";
          }
          if (hybridLiveDot) {
            hybridLiveDot.classList.add("off");
          }
        }

        // --- Hybrid paper trading ---
        const paperStatus = document.getElementById("paper-status");
        const paperLiveDot = document.getElementById("paper-live-dot");
        const paperTradesBody = document.getElementById("paper-trades-body");
        const paperConfig = {
          initialBalance: 10000,
          orderPct: 20,
          entryThreshold: 0.62,
          exitThreshold: 0.48,
          shortEntryThreshold: 0.38,
          shortExitThreshold: 0.52,
          takeProfitPct: 0.8,
          stopLossPct: -0.5,
        };
        const paperState = {
          cash: paperConfig.initialBalance,
          equity: paperConfig.initialBalance,
          realizedPnl: 0,
          position: null,
          trades: [],
          lastAction: "대기 중",
        };
        let paperTimer = null;
        let paperActive = false;

        function applyPaperConfigFromInputs() {
          const map = [
            ["paper-initial-balance", "initialBalance"],
            ["paper-order-pct", "orderPct"],
            ["paper-entry-threshold", "entryThreshold"],
            ["paper-short-entry", "shortEntryThreshold"],
            ["paper-exit-threshold", "exitThreshold"],
            ["paper-short-exit", "shortExitThreshold"],
            ["paper-tp", "takeProfitPct"],
            ["paper-sl", "stopLossPct"],
          ];
          map.forEach(function ([id, key]) {
            const el = document.getElementById(id);
            if (!el) return;
            if (el.value === "" || el.value === null) {
              el.value = paperConfig[key];
              return;
            }
            const val = parseFloat(el.value);
            if (!Number.isNaN(val)) {
              paperConfig[key] = val;
            } else {
              el.value = paperConfig[key];
            }
          });
          paperConfig.initialBalance = Math.max(100, paperConfig.initialBalance);
          paperConfig.orderPct = Math.min(100, Math.max(1, paperConfig.orderPct));
          paperConfig.entryThreshold = Math.min(1, Math.max(0, paperConfig.entryThreshold));
          paperConfig.exitThreshold = Math.min(1, Math.max(0, paperConfig.exitThreshold));
          paperConfig.shortEntryThreshold = Math.min(1, Math.max(0, paperConfig.shortEntryThreshold));
          paperConfig.shortExitThreshold = Math.min(1, Math.max(0, paperConfig.shortExitThreshold));
          paperConfig.takeProfitPct = Math.max(0, paperConfig.takeProfitPct);
          paperConfig.stopLossPct = Math.min(-0.01, paperConfig.stopLossPct);
        }

        function resetPaperState(clearTrades) {
          paperState.cash = paperConfig.initialBalance;
          paperState.equity = paperConfig.initialBalance;
          paperState.realizedPnl = 0;
          paperState.position = null;
          if (clearTrades) {
            paperState.trades = [];
          }
          paperState.lastAction = "대기 중";
          renderPaperState();
          renderPaperTrades();
        }

        function renderPaperTrades() {
          if (!paperTradesBody) return;
          if (!paperState.trades.length) {
            paperTradesBody.innerHTML =
              '<tr><td colspan="7" class="value-muted">모의 체결이 없습니다.</td></tr>';
            return;
          }
          const rows = [];
          const recent = paperState.trades.slice(-20).reverse();
          recent.forEach(function (t) {
            const pnlClass = t.pnl >= 0 ? "value-up" : "value-down";
            rows.push(
              "<tr>" +
                "<td>" +
                (t.side === "short" ? "숏" : "롱") +
                "</td>" +
                '<td class="value-muted">' +
                t.entryTime +
                "</td>" +
                '<td class="value-muted">' +
                t.exitTime +
                "</td>" +
                "<td>" +
                t.entry.toFixed(2) +
                "</td>" +
                "<td>" +
                t.exit.toFixed(2) +
                "</td>" +
                '<td class="' +
                pnlClass +
                '">' +
                t.pnl.toFixed(4) +
                " (" +
                t.pnlPct.toFixed(2) +
                "%)" +
                "</td>" +
                "<td>" +
                t.entryProb.toFixed(3) +
                "→" +
                t.exitProb.toFixed(3) +
                "</td>" +
                "</tr>",
            );
          });
          paperTradesBody.innerHTML = rows.join("");
        }

        function renderPaperState(payload) {
          const price = payload?.latest && payload.latest.close != null ? parseFloat(payload.latest.close) : lastPrice;
          const probVal = payload ? parseFloat(payload.prob_ensemble || 0) : null;
          const pos = paperState.position;
          const positionValue = pos && price ? pos.qty * price : 0;
          const unrealized = pos ? positionValue - pos.entryPrice * pos.qty : 0;
          const unrealizedPct = pos ? ((price - pos.entryPrice) / pos.entryPrice) * 100 : 0;
          paperState.equity = paperState.cash + positionValue;
          const totalPnl = paperState.realizedPnl + unrealized;

          const setText = (id, text) => {
            const el = document.getElementById(id);
            if (el) el.textContent = text;
          };

          setText("paper-equity", paperState.equity.toFixed(2));
          setText("paper-cash", paperState.cash.toFixed(2));
          setText("paper-pnl", (totalPnl >= 0 ? "+" : "") + totalPnl.toFixed(4));
          setText("paper-trade-count", paperState.trades.length);
          setText("paper-last-action", paperState.lastAction);

          const positionState = document.getElementById("paper-position-state");
          if (positionState) {
            positionState.classList.remove("chip-up", "chip-down", "chip-neutral");
            if (pos) {
              positionState.classList.add(pos.side === "short" ? "chip-down" : "chip-up");
              positionState.textContent = pos.side === "short" ? "숏 보유" : "롱 보유";
            } else {
              positionState.classList.add("chip-neutral");
              positionState.textContent = "미보유";
            }
          }
          setText(
            "paper-position-size",
            pos ? (pos.side === "short" ? "숏 " : "롱 ") + Math.abs(pos.qty).toFixed(4) + " @ " + pos.entryPrice.toFixed(2) : "-",
          );
          setText("paper-entry-price", pos ? pos.entryPrice.toFixed(2) : "-");
          setText("paper-current-price", price ? price.toFixed(2) : "-");
          setText(
            "paper-unrealized",
            pos ? unrealized.toFixed(4) + " (" + unrealizedPct.toFixed(2) + "%)" : "-",
          );

          const probChip = document.getElementById("paper-prob-chip");
          if (probChip) {
            probChip.classList.remove("chip-up", "chip-down", "chip-neutral");
            if (probVal >= paperConfig.entryThreshold) {
              probChip.classList.add("chip-up");
            } else if (probVal <= paperConfig.exitThreshold) {
              probChip.classList.add("chip-down");
            } else {
              probChip.classList.add("chip-neutral");
            }
            probChip.textContent = Number.isFinite(probVal) ? "prob " + probVal.toFixed(3) : "prob";
          }
          setText("paper-prob", Number.isFinite(probVal) ? probVal.toFixed(3) : "-");
          setText("paper-horizon", payload?.label_horizon ?? "-");
          setText("paper-updated", payload?.timestamp ? new Date(payload.timestamp).toLocaleTimeString() : "-");
          setText("paper-price", price ? price.toFixed(2) : "-");
        }

        function handlePaperTick(payload) {
          if (!payload) return;
          const price = payload?.latest && payload.latest.close != null ? parseFloat(payload.latest.close) : lastPrice;
          const prob = parseFloat(payload.prob_ensemble || 0);
          if (!price || Number.isNaN(price)) {
            renderPaperState(payload);
            return;
          }
          const nowLabel = payload.timestamp ? new Date(payload.timestamp).toLocaleTimeString() : new Date().toLocaleTimeString();
          const pos = paperState.position;

          if (!pos && prob >= paperConfig.entryThreshold) {
            const notional = paperState.cash * (paperConfig.orderPct / 100);
            if (notional > 0) {
              const qty = notional / price;
              paperState.cash -= notional;
              paperState.position = { qty, entryPrice: price, entryProb: prob, entryTime: nowLabel, side: "long" };
              paperState.lastAction = "롱 진입 (" + prob.toFixed(3) + ")";
            }
          } else if (!pos && prob <= paperConfig.shortEntryThreshold) {
            const notional = paperState.cash * (paperConfig.orderPct / 100);
            if (notional > 0) {
              const qty = -(notional / price);
              paperState.cash += notional; // 숏 체결 금액 유입
              paperState.position = { qty, entryPrice: price, entryProb: prob, entryTime: nowLabel, side: "short" };
              paperState.lastAction = "숏 진입 (" + prob.toFixed(3) + ")";
            }
          } else if (pos) {
            const entryNotional = Math.abs(pos.entryPrice * pos.qty);
            const pnl = (price - pos.entryPrice) * pos.qty;
            const pnlPct = entryNotional > 0 ? (pnl / entryNotional) * 100 : 0;
            const tpHit = paperConfig.takeProfitPct > 0 && pnlPct >= paperConfig.takeProfitPct;
            const slHit = pnlPct <= paperConfig.stopLossPct;
            const probExit =
              (pos.side === "long" && prob <= paperConfig.exitThreshold) ||
              (pos.side === "short" && prob >= paperConfig.shortExitThreshold);
            if (tpHit || slHit || probExit) {
              const exitValue = price * pos.qty;
              const pnlPctTrade = pnlPct;
              paperState.cash += exitValue;
              paperState.realizedPnl += pnl;
              paperState.trades.push({
                side: pos.side,
                entryTime: pos.entryTime,
                exitTime: nowLabel,
                entry: pos.entryPrice,
                exit: price,
                pnl,
                pnlPct: pnlPctTrade,
                entryProb: pos.entryProb,
                exitProb: prob,
              });
              if (paperState.trades.length > 50) {
                paperState.trades.shift();
              }
              paperState.position = null;
              if (tpHit) {
                paperState.lastAction = "익절 청산";
              } else if (slHit) {
                paperState.lastAction = "손절 청산";
              } else {
                paperState.lastAction = (pos.side === "short" ? "숏" : "롱") + " prob 청산";
              }
            } else {
              paperState.lastAction = (pos.side === "short" ? "숏" : "롱") + " 보유 (prob " + prob.toFixed(3) + ")";
            }
          }

          renderPaperState(payload);
          renderPaperTrades();
          if (paperLiveDot) {
            paperLiveDot.classList.remove("off");
          }
          if (paperStatus) {
            paperStatus.textContent = "실시간 수신 " + nowLabel;
          }
        }

        async function fetchPaperTick() {
          if (!paperActive || activeTab !== "paper") return;
          if (paperStatus) {
            paperStatus.textContent = "실시간 예측 요청 중…";
          }
          if (paperLiveDot) {
            paperLiveDot.classList.add("off");
          }
          try {
            const data = await fetchHybridData();
            handlePaperTick(data);
            if (paperLiveDot) {
              paperLiveDot.classList.remove("off");
            }
            if (paperStatus) {
              paperStatus.textContent = "prob 갱신 " + new Date().toLocaleTimeString();
            }
          } catch (err) {
            if (paperStatus) {
              paperStatus.textContent = "에러: " + err.message;
            }
          }
        }

        function startPaperTrading() {
          if (activeTab !== "paper") return;
          applyPaperConfigFromInputs();
          paperActive = true;
          if (paperStatus) {
            paperStatus.textContent = "실시간 시뮬레이션 시작";
          }
          if (paperLiveDot) {
            paperLiveDot.classList.remove("off");
          }
          startHybridStream();
          startPriceStream();
        }

        function stopPaperTrading() {
          paperActive = false;
          if (paperStatus) {
            paperStatus.textContent = "탭 비활성 · 시뮬레이션 정지";
          }
          if (paperLiveDot) {
            paperLiveDot.classList.add("off");
          }
          stopPriceStream();
        }

        function initPaperForm() {
          const defaults = {
            "paper-initial-balance": paperConfig.initialBalance,
            "paper-order-pct": paperConfig.orderPct,
            "paper-entry-threshold": paperConfig.entryThreshold,
            "paper-short-entry": paperConfig.shortEntryThreshold,
            "paper-exit-threshold": paperConfig.exitThreshold,
            "paper-short-exit": paperConfig.shortExitThreshold,
            "paper-tp": paperConfig.takeProfitPct,
            "paper-sl": paperConfig.stopLossPct,
          };
          Object.entries(defaults).forEach(function ([id, value]) {
            const el = document.getElementById(id);
            if (el && (el.value === "" || el.value === null)) {
              el.value = value;
            }
          });
          applyPaperConfigFromInputs();
          resetPaperState(true);
          const form = document.getElementById("paper-config");
          if (form) {
            form.addEventListener("change", function () {
              applyPaperConfigFromInputs();
            });
          }
          const resetBtn = document.getElementById("paper-reset-btn");
          if (resetBtn) {
            resetBtn.addEventListener("click", function () {
              applyPaperConfigFromInputs();
              resetPaperState(true);
            });
          }
        }

        function initTimeframeButtons() {
          const buttons = document.querySelectorAll(".tf-btn");
          buttons.forEach(function (btn) {
            btn.addEventListener("click", function () {
              const tf = btn.getAttribute("data-tf");
              if (!tf || tf === currentTf) return;
              currentTf = tf;
              buttons.forEach(function (b) {
                b.classList.remove("active");
              });
              btn.classList.add("active");
              if (activeTab === "binance") {
                startBinanceMode(tf);
              }
            });
          });
        }

        function initTabs() {
          const tabsContainer = document.querySelector(".tabs");
          const tabs = document.querySelectorAll(".tab-btn");
          const contents = document.querySelectorAll(".tab-content");

          function activate(target) {
            if (!target) return;
            activeTab = target;

            tabs.forEach(function (t) {
              t.classList.remove("active");
            });
            contents.forEach(function (c) {
              c.classList.remove("active");
            });
            const btn = document.querySelector('.tab-btn[data-tab="' + target + '"]');
            if (btn) {
              btn.classList.add("active");
            }
            const pane = document.getElementById("tab-" + target);
            if (pane) {
              pane.classList.add("active");
            }

            stopBinanceMode();
            stopHybridStream();
            stopPaperTrading();

            if (target === "binance") {
              startBinanceMode(currentTf);
            } else if (target === "hybrid") {
              startHybridStream();
            } else if (target === "paper") {
              startPaperTrading();
            }
          }

          tabs.forEach(function (tab) {
            tab.addEventListener("click", function () {
              const target = tab.getAttribute("data-tab");
              activate(target);
            });
          });

          const requested = tabsContainer ? tabsContainer.getAttribute("data-active-tab") : null;
          const initial =
            (requested && document.querySelector('.tab-btn[data-tab="' + requested + '"]')?.getAttribute("data-tab")) ||
            (tabs[0] ? tabs[0].getAttribute("data-tab") : "binance");
          activate(initial);
        }

        initPaperForm();
        initTimeframeButtons();
        initTabs();
      })();
    </script>
  </body>
</html>
